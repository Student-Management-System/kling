/**
 * Kling-API
 * The Kling-API. <a href='http://localhost:3100/api-json'>JSON</a>
 *
 * OpenAPI spec version: 1.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */ /* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional } from "@angular/core";
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpEvent } from "@angular/common/http";
import { CustomHttpUrlEncodingCodec } from "../encoder";

import { Observable } from "rxjs";

import { ProblemCreateDto } from "../model/problemCreateDto";
import { ProblemDto } from "../model/problemDto";

import { BASE_PATH, COLLECTION_FORMATS } from "../variables";
import { Configuration } from "../configuration";

@Injectable()
export class ProblemService {
	protected basePath = "/";
	public defaultHeaders = new HttpHeaders();
	public configuration = new Configuration();

	constructor(
		protected httpClient: HttpClient,
		@Optional() @Inject(BASE_PATH) basePath: string,
		@Optional() configuration: Configuration
	) {
		if (basePath) {
			this.basePath = basePath;
		}
		if (configuration) {
			this.configuration = configuration;
			this.basePath = basePath || configuration.basePath || this.basePath;
		}
	}

	/**
	 * @param consumes string[] mime-types
	 * @return true: consumes contains 'multipart/form-data', false: otherwise
	 */
	private canConsumeForm(consumes: string[]): boolean {
		const form = "multipart/form-data";
		for (const consume of consumes) {
			if (form === consume) {
				return true;
			}
		}
		return false;
	}

	/**
	 * Create problem.
	 * Creates a new problem.
	 * @param body
	 * @param problemId
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public createProblem(
		body: ProblemCreateDto,
		problemId: string,
		observe?: "body",
		reportProgress?: boolean
	): Observable<ProblemDto>;
	public createProblem(
		body: ProblemCreateDto,
		problemId: string,
		observe?: "response",
		reportProgress?: boolean
	): Observable<HttpResponse<ProblemDto>>;
	public createProblem(
		body: ProblemCreateDto,
		problemId: string,
		observe?: "events",
		reportProgress?: boolean
	): Observable<HttpEvent<ProblemDto>>;
	public createProblem(
		body: ProblemCreateDto,
		problemId: string,
		observe: any = "body",
		reportProgress: boolean = false
	): Observable<any> {
		if (body === null || body === undefined) {
			throw new Error(
				"Required parameter body was null or undefined when calling createProblem."
			);
		}

		if (problemId === null || problemId === undefined) {
			throw new Error(
				"Required parameter problemId was null or undefined when calling createProblem."
			);
		}

		let headers = this.defaultHeaders;

		// to determine the Accept header
		let httpHeaderAccepts: string[] = ["application/json"];
		const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(
			httpHeaderAccepts
		);
		if (httpHeaderAcceptSelected != undefined) {
			headers = headers.set("Accept", httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ["application/json"];
		const httpContentTypeSelected:
			| string
			| undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected != undefined) {
			headers = headers.set("Content-Type", httpContentTypeSelected);
		}

		return this.httpClient.request<ProblemDto>(
			"put",
			`${this.basePath}/problems/${encodeURIComponent(String(problemId))}`,
			{
				body: body,
				withCredentials: this.configuration.withCredentials,
				headers: headers,
				observe: observe,
				reportProgress: reportProgress
			}
		);
	}

	/**
	 * Find problems.
	 * Retrieves all problems that match the the specified filter.
	 * @param skip [Pagination] The amount of elements that should be skipped.
	 * @param take [Pagination] The amount of elements that should be included in the response.
	 * @param title
	 * @param difficulties
	 * @param categories
	 * @param status
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public findProblems(
		skip?: number,
		take?: number,
		title?: string,
		difficulties?: Array<string>,
		categories?: Array<string>,
		status?: string,
		observe?: "body",
		reportProgress?: boolean
	): Observable<Array<ProblemDto>>;
	public findProblems(
		skip?: number,
		take?: number,
		title?: string,
		difficulties?: Array<string>,
		categories?: Array<string>,
		status?: string,
		observe?: "response",
		reportProgress?: boolean
	): Observable<HttpResponse<Array<ProblemDto>>>;
	public findProblems(
		skip?: number,
		take?: number,
		title?: string,
		difficulties?: Array<string>,
		categories?: Array<string>,
		status?: string,
		observe?: "events",
		reportProgress?: boolean
	): Observable<HttpEvent<Array<ProblemDto>>>;
	public findProblems(
		skip?: number,
		take?: number,
		title?: string,
		difficulties?: Array<string>,
		categories?: Array<string>,
		status?: string,
		observe: any = "body",
		reportProgress: boolean = false
	): Observable<any> {
		let queryParameters = new HttpParams({ encoder: new CustomHttpUrlEncodingCodec() });
		if (skip !== undefined && skip !== null) {
			queryParameters = queryParameters.set("skip", <any>skip);
		}
		if (take !== undefined && take !== null) {
			queryParameters = queryParameters.set("take", <any>take);
		}
		if (title !== undefined && title !== null) {
			queryParameters = queryParameters.set("title", <any>title);
		}
		if (difficulties) {
			difficulties.forEach(element => {
				queryParameters = queryParameters.append("difficulties", <any>element);
			});
		}
		if (categories) {
			categories.forEach(element => {
				queryParameters = queryParameters.append("categories", <any>element);
			});
		}
		if (status !== undefined && status !== null) {
			queryParameters = queryParameters.set("status", <any>status);
		}

		let headers = this.defaultHeaders;

		// to determine the Accept header
		let httpHeaderAccepts: string[] = ["application/json"];
		const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(
			httpHeaderAccepts
		);
		if (httpHeaderAcceptSelected != undefined) {
			headers = headers.set("Accept", httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = [];

		return this.httpClient.request<Array<ProblemDto>>("get", `${this.basePath}/problems`, {
			params: queryParameters,
			withCredentials: this.configuration.withCredentials,
			headers: headers,
			observe: observe,
			reportProgress: reportProgress
		});
	}

	/**
	 * Get problem.
	 * Retrieves the problem with the specified Id. Throws error, if problem does not exist.
	 * @param problemId
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public getProblem(
		problemId: string,
		observe?: "body",
		reportProgress?: boolean
	): Observable<ProblemDto>;
	public getProblem(
		problemId: string,
		observe?: "response",
		reportProgress?: boolean
	): Observable<HttpResponse<ProblemDto>>;
	public getProblem(
		problemId: string,
		observe?: "events",
		reportProgress?: boolean
	): Observable<HttpEvent<ProblemDto>>;
	public getProblem(
		problemId: string,
		observe: any = "body",
		reportProgress: boolean = false
	): Observable<any> {
		if (problemId === null || problemId === undefined) {
			throw new Error(
				"Required parameter problemId was null or undefined when calling getProblem."
			);
		}

		let headers = this.defaultHeaders;

		// to determine the Accept header
		let httpHeaderAccepts: string[] = ["application/json"];
		const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(
			httpHeaderAccepts
		);
		if (httpHeaderAcceptSelected != undefined) {
			headers = headers.set("Accept", httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = [];

		return this.httpClient.request<ProblemDto>(
			"get",
			`${this.basePath}/problems/${encodeURIComponent(String(problemId))}`,
			{
				withCredentials: this.configuration.withCredentials,
				headers: headers,
				observe: observe,
				reportProgress: reportProgress
			}
		);
	}

	/**
	 * Remove problem.
	 * Removes the problem and all its related data (i.e. submissions, code templates, etc.)
	 * @param problemId
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public removeProblem(
		problemId: string,
		observe?: "body",
		reportProgress?: boolean
	): Observable<any>;
	public removeProblem(
		problemId: string,
		observe?: "response",
		reportProgress?: boolean
	): Observable<HttpResponse<any>>;
	public removeProblem(
		problemId: string,
		observe?: "events",
		reportProgress?: boolean
	): Observable<HttpEvent<any>>;
	public removeProblem(
		problemId: string,
		observe: any = "body",
		reportProgress: boolean = false
	): Observable<any> {
		if (problemId === null || problemId === undefined) {
			throw new Error(
				"Required parameter problemId was null or undefined when calling removeProblem."
			);
		}

		let headers = this.defaultHeaders;

		// to determine the Accept header
		let httpHeaderAccepts: string[] = [];
		const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(
			httpHeaderAccepts
		);
		if (httpHeaderAcceptSelected != undefined) {
			headers = headers.set("Accept", httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = [];

		return this.httpClient.request<any>(
			"delete",
			`${this.basePath}/problems/${encodeURIComponent(String(problemId))}`,
			{
				withCredentials: this.configuration.withCredentials,
				headers: headers,
				observe: observe,
				reportProgress: reportProgress
			}
		);
	}

	/**
	 * Update problem.
	 * Updates the problem partially.
	 * @param body
	 * @param problemId
	 * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
	 * @param reportProgress flag to report request and response progress.
	 */
	public updateProblem(
		body: ProblemDto,
		problemId: string,
		observe?: "body",
		reportProgress?: boolean
	): Observable<ProblemDto>;
	public updateProblem(
		body: ProblemDto,
		problemId: string,
		observe?: "response",
		reportProgress?: boolean
	): Observable<HttpResponse<ProblemDto>>;
	public updateProblem(
		body: ProblemDto,
		problemId: string,
		observe?: "events",
		reportProgress?: boolean
	): Observable<HttpEvent<ProblemDto>>;
	public updateProblem(
		body: ProblemDto,
		problemId: string,
		observe: any = "body",
		reportProgress: boolean = false
	): Observable<any> {
		if (body === null || body === undefined) {
			throw new Error(
				"Required parameter body was null or undefined when calling updateProblem."
			);
		}

		if (problemId === null || problemId === undefined) {
			throw new Error(
				"Required parameter problemId was null or undefined when calling updateProblem."
			);
		}

		let headers = this.defaultHeaders;

		// to determine the Accept header
		let httpHeaderAccepts: string[] = ["application/json"];
		const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(
			httpHeaderAccepts
		);
		if (httpHeaderAcceptSelected != undefined) {
			headers = headers.set("Accept", httpHeaderAcceptSelected);
		}

		// to determine the Content-Type header
		const consumes: string[] = ["application/json"];
		const httpContentTypeSelected:
			| string
			| undefined = this.configuration.selectHeaderContentType(consumes);
		if (httpContentTypeSelected != undefined) {
			headers = headers.set("Content-Type", httpContentTypeSelected);
		}

		return this.httpClient.request<ProblemDto>(
			"patch",
			`${this.basePath}/problems/${encodeURIComponent(String(problemId))}`,
			{
				body: body,
				withCredentials: this.configuration.withCredentials,
				headers: headers,
				observe: observe,
				reportProgress: reportProgress
			}
		);
	}
}
